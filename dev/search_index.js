var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = StructHelpers","category":"page"},{"location":"#StructHelpers","page":"Home","title":"StructHelpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for StructHelpers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [StructHelpers]","category":"page"},{"location":"#StructHelpers.has_batteries-Tuple{Type}","page":"Home","title":"StructHelpers.has_batteries","text":"has_batteries(T::Type)::Bool\n\nCheck if @batteries or @enumbatteries was applied to T.\n\n\n\n\n\n","category":"method"},{"location":"#StructHelpers.hash_eq_as-Tuple{Any}","page":"Home","title":"StructHelpers.hash_eq_as","text":"hash_eq_as(obj)\n\nThis allows to fine tune the behavior or hash, == and isequal for structs decorated by @batteries. For instances the generated isequal method looks like this:\n\nfunction Base.isequal(o1::T, o2::T)\n    proxy1 = StructHelpers.hash_eq_as(o1)\n    proxy2 = StructHelpers.hash_eq_as(o2)\n    isequal(proxy1, proxy2)\nend\n\nOverloading hash_eq_as is useful for instance if you want to skip certain fields of obj or handle them in a special way.\n\n\n\n\n\n","category":"method"},{"location":"#StructHelpers.@batteries-Tuple{Any, Vararg{Any}}","page":"Home","title":"StructHelpers.@batteries","text":"@batteries T [options]\n\nAutomatically derive several methods for type T.\n\nExample\n\nstruct S\n    a\n    b\nend\n\n@batteries S\n@batteries S hash=false # don't overload `Base.hash`\n@batteries S kwconstructor=true # add a keyword constructor\n\nSupported options and defaults are:\n\neq = true:\n\nDefine Base.(==) structurally.\n\nisequal = true:\n\nDefine Base.isequal structurally.\n\nhash = true:\n\nDefine Base.hash structurally.\n\nkwconstructor = false:\n\nAdd a keyword constructor.\n\nselfconstructor = true:\n\nAdd a constructor of the for T(self::T) = self\n\nkwshow = false:\n\nOverload Base.show such that the names of each field are printed.\n\ngetproperties = true:\n\nOverload ConstructionBase.getproperties.\n\nconstructorof = true:\n\nOverload ConstructionBase.constructorof.\n\ntypesalt = nothing:\n\nOnly used if hash=true. In this case the hash will be purely computed from typesalt and hash_eq_as(obj). The type T will not be used otherwise. This makes the hash more likely to stay constant, when executing on a different machine or julia version\n\nStructTypes = false:\n\nOverload StructTypes.StructType to be Struct(). Needs the StructTypes.jl package to be installed.\n\nSee also hash_eq_as\n\n\n\n\n\n","category":"macro"},{"location":"#StructHelpers.@enumbatteries-Tuple{Any, Vararg{Any}}","page":"Home","title":"StructHelpers.@enumbatteries","text":"@enumbatteries T [options]\n\nAutomatically derive several methods for Enum type T.\n\nExample\n\n@enum Color Red Blue Yellow\n@enumbatteries Color\n@enumbatteries Color hash=false # don't overload `Base.hash`\n@enumbatteries Color symbol_conversion=true # allow convert(Color, :Blue), Color(:Blue), convert(Symbol, Blue), Symbol(Blue)\n\nSupported options and defaults are:\n\nstring_conversion = false:\n\nAdd convert(MyEnum, ::String), MyEnum(::String), convert(String, ::MyEnum) and String(::MyEnum)\n\nsymbol_conversion = false:\n\nAdd convert(MyEnum, ::Symbol), MyEnum(::Symbol), convert(Symbol, ::MyEnum) and Symbol(::MyEnum)\n\nselfconstructor = true:\n\nAdd a constructor of the for T(self::T) = self\n\n\n\n\n\n","category":"macro"}]
}
